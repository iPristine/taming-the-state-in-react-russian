## Масштабирование локального состояния в React.JS

Вы должны знать все основы управления локальным состоянием в React к этому моменту. Тем не менее, вы заметите, что существует больше шаблонов и рекомендаций для применения локального состояния в масштабирующем приложении. Следующая глава даст вам понимание этих тем.

### Подъем сосотояния

В масштабируемом приложении вы заметите, что вы передаете много состояний дочерним компонентам в качестве пропса. Эти пропсы часто передаются по нескольким уровням компонентов. Вот как состояние делится вертикально в вашем приложении. Тем не менее, с другой стороны, вы заметите, больше компонентов использует и, таким образом,  делят одно и то же состояние. Поэтому нужно распределять состояние по горизонтали между компонентами в дереве компонентов. Эти две проблемы масштабирования, распределение состояние по вертикали и горизонтали, распространены в локальном управлении состояниями. Поэтому вы можете поднимать и опускать состояние, чтобы поддерживать работоспособность локального состояния. Поднятие состояния предотвращает распределение чрезмерно большого или слишком малого состояния в дереве компонентов. По сути, это рефакторинг, который вы должны выполнять время от времени, чтобы поддерживать компоненты в удобном для обслуживания состоянии и сосредоточиться только на том состоянии, которое им требуется.

Для того, чтобы понять подъем и спуск локального состояния, следующая глава продемонстрирует это двумя примерами. Первый пример, который демонстрирует подъем состояния, называется: «Search a List» . Второй пример, демонстрирующий спуск состояния, называется «Архив в списке».

Пример «Поиск по списку» состоит из трех компонентов. Два родственных компонента, компонент `Поиск` и компонент `Список`, которые используются в объединяющем компоненте `SearchableList`. Сначала реализация компонента `Поиск`:

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class Search extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      query: ''
    };

    this.onChange = this.onChange.bind(this);
  }

  onChange(event) {
    const { value } = event.target;

    this.setState({
      query: value
    });
  }

  render() {
    return (
      <div>
        {this.props.children} <input
          type="text"
          value={this.state.query}
          onChange={this.onChange}
        />
      </div>
    );
  }
}
~~~~~~~~

Теперь реализация компонента `List`:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function List({ list }) {
  return (
    <ul>
      {list.map(item => <li key={item.id}>{item.name}</li>)}
    </ul>
  );
}
~~~~~~~~

Теперь компонент `SearchableList`, который использует оба компонента, компоненты` Search` и `List`, и, таким образом, оба компонента становятся родственными элементами в дереве компонентов:

{title="Code Playground",lang="javascript"}
~~~~~~~~
function SearchableList({ list }) {
  return (
    <div>
      <Search>Search List:</Search>
      <List list={list} />
    </div>
  );
}
~~~~~~~~

В то время как компонент `Search` является компонентом  на основе классов ES6 с состоянием, компонент `List` является только функциональным компонентом без состояния. Родительский компонент, который объединяет компоненты `List` и `Search` в компонент `SearchableList`, также является функциональным компонентом без состояния.

Однако пример не работает. Компонент `Search` знает о `query`, который можно использовать для фильтрации списка, но компонент `List` не знает об этом. Состояние из компонента «Search» может спускаться по дереву компонента с помощью пропсов, но не подниматься. Следовательно, вам необходимо поднять состояние компонента `Search` до `SearchableList`, чтобы сделать состояние `query` доступным для компонента `List`, чтобы в конечном итоге отфильтровать список. Вы хотите получать состояние `query` как в компоненте` List`, так и в компоненте `Search`. Принимая во внимание, что компонент `Search` отвечает за изменение состояния, компонент `List` использует состояние для фильтрации списка элементов. Состояние должно управляться в компоненте `SearchableList`, чтобы сделать его читаемым и доступным для записи для обоих родственных компонентов ниже.

Чтобы поднять состояние, SearchableList становится компонентом с состоянием. Вы должны реорганизовать его в React компонент на основе классов ES6. Затем, вы можете реорганизовать компонент `Search` в функциональный компонент без состояния, так как он больше не должен хранить состояние. Родительский компонент с состоянием заботится обо всем своем состоянии. В других случаях компонент `Search` может оставаться компонентом на основе классов ES6 с состояния, поскольку он по-прежнему управляет некоторым другим состоянием, но в данном примере это не так. Итак снасчала это реорганизованный компонент `Search`:

{title="Code Playground",lang="javascript"}
~~~~~~~~
# leanpub-start-insert
function Search({ query, onChange, children }) {
# leanpub-end-insert
  return (
    <div>
      {children} <input
        type="text"
# leanpub-start-insert
        value={query}
        onChange={onChange}
# leanpub-end-insert
      />
    </div>
  );
}
~~~~~~~~

Теперь реорганизованный компонент `SearchableList`:

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class SearchableList extends React.Component {
  constructor(props) {
    super(props);

# leanpub-start-insert
    this.state = {
      query: ''
    };

    this.onChange = this.onChange.bind(this);
  }

  onChange(event) {
    const { value } = event.target;

    this.setState({
      query: value
    });
  }
# leanpub-end-insert

  render() {
    const { list } = this.props;
# leanpub-start-insert
    const { query } = this.state;
# leanpub-end-insert

    return (
      <div>
        <Search
# leanpub-start-insert
          query={query}
          onChange={this.onChange}
# leanpub-end-insert
        >
          Search List:
        </Search>
# leanpub-start-insert
        <List list={(list || []).filter(byQuery(query))} />
# leanpub-end-insert
      </div>
    );
  }
}

# leanpub-start-insert
function byQuery(query) {
  return function(item) {
    return !query ||
      item.name.toLowerCase().includes(query.toLowerCase());
  }
}
# leanpub-end-insert
~~~~~~~~

После того как вы подняли состояние, родительский компонент позаботится об управлении локальными состояниями. Оба дочерних компонента не должны сохранять и обновлять его. Вы подняли состояние, чтобы разделить локальное состояние между дочерними компонентами. Список фильтруется поисковым запросом до того, как он достигает компонента `List`. Альтернативой может быть передача состояния `query` в качестве пропса компоненту` List`, а компонент `List` будет применять фильтр к списку.

Теперь давайте перейдем ко второму примеру: «Архив в списке». Он основан на предыдущем примере, но на этот раз компонент `List` обладает расширенной функциональностью для архивирования элемента в списке. Следовательно, он должн иметь кнопку для архивирования элемента в списке, идентифицируемого уникальным свойством `id` элемента. Вот расширенный компонент `List`:

{title="Code Playground",lang="javascript"}
~~~~~~~~
# leanpub-start-insert
function List({ list, onArchive }) {
# leanpub-end-insert
  return (
    <ul>
      {list.map(item =>
        <li key={item.id}>
          <span>
            {item.name}
          </span>
# leanpub-start-insert
          <span>
            <button
              type="button"
              onClick={() => onArchive(item.id)}
            >
              Archive
            </button>
# leanpub-end-insert
          </span>
        </li>
      )}
    </ul>
  );
}
~~~~~~~~

А вот компонент SearchableList, который хранит состояние архивных элементов:

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class SearchableList extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      query: '',
# leanpub-start-insert
      archivedItems: []
# leanpub-end-insert
    };

    this.onChange = this.onChange.bind(this);
# leanpub-start-insert
    this.onArchive = this.onArchive.bind(this);
# leanpub-end-insert
  }

  ...

# leanpub-start-insert
  onArchive(id) {
    const { archivedItems } = this.state;

    this.setState({
      archivedItems: [...archivedItems, id]
    });
  }
# leanpub-end-insert

  render() {
    const { list } = this.props;
# leanpub-start-insert
    const { query, archivedItems } = this.state;

    const filteredList = list
      .filter(byQuery(query))
      .filter(byArchived(archivedItems));
# leanpub-end-insert

    return (
      <div>
        ...
        <List
# leanpub-start-insert
          list={filteredList}
          onArchive={this.onArchive}
# leanpub-end-insert
        />
      </div>
    );
  }
}

...

# leanpub-start-insert
function byArchived(archivedItems) {
  return function(item) {
    return !archivedItems.includes(item.id);
  }
}
# leanpub-end-insert
~~~~~~~~

Компонент `Search` остается без изменений. Как вы видите, предыдущий пример был расширен для облегчения архивирования элементов в списке. Теперь компонент `List` получает все необходимые свойства: функцию обратного вызова `onArchive()` и список, отфильтрованный с помощью `query` и `archivedItems`. Он показывает только элементы, отфильтрованные по запросу из компонента «Поиск», и элементы, которые не были заархивированы.

Вы уже можете увидеть недостаток. `SearchableList` заботится о функциональности архивирования. Тем не менее, он не нуждается в самой функциональности. Он только передает все состояния компоненту `List` как пропсы. Он управляет состоянием от имени компонента `List`. Никакой другой компонент не нуждается об этом состоянии. В масштабирующем приложении имеет смысл поднять состояние до компонента `List`, потому что только компонент `List` нуждается в этом состоянии, и никакой другой компонент не должен управлять им от имени компонента `List`. Несмотря на то, что компонент `List` станет компонентом с состоянием, это является шагом в правильном направлении, сохраняя локальное состояние поддерживаемым в долгосрочной перспективе. Для начала расширяем компонент `List` чтобы он начал управлять состоянием

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

# leanpub-start-insert
class List extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      archivedItems: []
    };

    this.onArchive = this.onArchive.bind(this);
  }

  onArchive(id) {
    const { archivedItems } = this.state;

    this.setState({
      archivedItems: [...archivedItems, id]
    });
  }
# leanpub-end-insert

  render() {
    const { list } = this.props;
# leanpub-start-insert
    const { archivedItems } = this.state;

    const filteredList = list
      .filter(byArchived(archivedItems));
# leanpub-end-insert

    return (
      <ul>
# leanpub-start-insert
        {filteredList.map(item =>
# leanpub-end-insert
          <li key={item.id}>
            <span>
              {item.name}
            </span>
            <span>
              <button
                type="button"
# leanpub-start-insert
                onClick={() => this.onArchive(item.id)}
# leanpub-end-insert
              >
                Archive
              </button>
            </span>
          </li>
        )}
      </ul>
    );
  }
}
~~~~~~~~

Теперь компонент `SearchableList`, который заботится только о состоянии из предыдущего примера, но не о заархивированных элементах:

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class SearchableList extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      query: ''
    };

    this.onChange = this.onChange.bind(this);
  }

  ...

  render() {
    const { list } = this.props;
# leanpub-start-insert
    const { query } = this.state;

    const filteredList = list
      .filter(byQuery(query));
# leanpub-end-insert

    return (
      <div>
        ...
# leanpub-start-insert
        <List list={filteredList} />
# leanpub-end-insert
      </div>
    );
  }
}
~~~~~~~~

Вот как вы можете поднять состояние. Сохранение состояния используется только компонентом, который нуждается в состоянии. Давайте вспомним оба подхода. В первом примере, например `Поиск в списке`, необходимо было поднять состояние, чтобы разделить свойство `query` с двумя дочерними компонентами. Компонент `Search` должен был манипулировать состоянием с помощью функции обратного вызова, но также должен был использовать` query`, чтобы быть контролируемым компонентом относительно поля ввода. С другой стороны, компоненту `SearchableList` пришлось отфильтровать список, используя свойство `query` от имени компонента `List`. Другим решением было бы передать свойство `query` компоненту` List` и позволить компоненту иметь дело с самой фильтрацией. В конце концов, состояние поднялось вверх по дереву компонентов, чтобы разделить его по вертикали между несколькими компонентами.

Во втором примере, «Архив в списке», состояние может быть спущено, чтобы поддерживать состояние в долгосрочной перспективе. Родительский компонент не должен беспокоиться о состоянии, которое не используется самим родительским компонентом и не используется несколькими дочерними компонентами. Поскольку только один дочерний компонент заботился об архивированных элементах, было хорошим изменением поднять состояние до единственного компонента, который заботится о состоянии. В конце концов, состояние было удалено из дерева компонентов.

В заключение, подъем состояния позволяет вам поддерживать управление локальным состоянием. **Подъем состояние должен использоваться, чтобы предоставить компонентам доступ ко всему состоянию, в котором они нуждаются, но не к большему, чем им необходимо.** Иногда вам необходимо реорганизовать компоненты из функционального компонента без состояния в React компонент основанный на классах ES6 или наоборот. Это не всегда возможно, потому что компонент, который может стать функциональным компонентом без состояния, может иметь другие свойства с состоянием.

### Функциональное состояние

В предыдущих главах вы использовали `this.setState()` для изменения локального состояния. Однако есть недостаток в использовании `this.setState()`, как мы это делали в прошлых главах для определенных случаев использования. Важно знать, что `this.setState()` выполняется асинхронно для обновления локального состояния. React упаковывает все обновления состояния, потом выполняет их друг за другом для оптимизации производительности. Таким образом, метод `this.setState()` работает в двух версиях.

В первой версии метод `this.setState()` принимает объект для обновления состояния. Как объяснялось в предыдущей главе, слияние объекта является поверхностным слиянием. Например, при обновлении `авторы` в объекте состояния `авторы` и `статьи`, `статьи` остаются неизменными. Предыдущие примеры уже использовали этот подход:

{title="Code Playground",lang="javascript"}
~~~~~~~~
this.setState({
  ...
});
~~~~~~~~

Во второй версии метод this.setState () принимает функцию в качестве аргумента.У функция есть предыдущее состояние и пропсы в аргументах для обновления состояния.

{title="Code Playground",lang="javascript"}
~~~~~~~~
this.setState((prevState, props) => ({
  ...
}));
~~~~~~~~

Итак, в чем заключается недостаток использования `this.setState()` с объектом? В нескольких примерах в последних главах состояние обновлялось на основе предыдущего состояния или пропса. Однако `this.setState()` выполняется асинхронно. Таким образом, состояние или пропсы, которые используются для выполнения обновления, могут быть устаревшими в данный момент времени, потому что состояние обновлялось более одного раза между ними. Это может привести к ошибкам в управлении локальным состоянием, потому что вы будете обновлять состояние на основе устаревших свойств. При использовании функционального подхода для обновления локального состояния, состояние и пропсы используются, когда `this.setState()` работает асинхронно во время его выполнения. Давайте вернемся к одному из предыдущих примеров:

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class CounterContainer extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0
    };

    this.onIncrement = this.onIncrement.bind(this);
    this.onDecrement = this.onDecrement.bind(this);
  }

  onIncrement() {
    this.setState({
      counter: this.state.counter + 1
    });
  }

  onDecrement() {
    this.setState({
      counter: this.state.counter - 1
    });
  }

  render() {
    return <CounterPresenter
      counter={this.state.counter}
      onIncrement={this.onIncrement}
      onDecrement={this.onDecrement}
    />
  }
}
~~~~~~~~

Выполнение одного из методов класса, `onIncrement()` или `onDecrement()`, несколько раз может привести к ошибке. Поскольку оба метода зависят от предыдущего состояния, он может использовать устаревшее состояние, когда между ними не было выполнено асинхронное обновление, а метод был вызван в другой раз.

{title="Code Playground",lang="javascript"}
~~~~~~~~
this.setState({ counter: this.state.counter + 1 }); // this.state: { counter: 0 }
this.setState({ counter: this.state.counter + 1 }); // this.state: { counter: 0 }
this.setState({ counter: this.state.counter + 1 }); // this.state: { counter: 0 }
// updated state: { counter: 1 }
// instead of: { counter: 3 }
~~~~~~~~

Это становится еще более подверженным ошибкам, когда несколько функций, таких как `onIncrement()` и `onDecrement()`, которые используют `this.setState()`, зависят от предыдущего состояния. Вы можете выполнить рефакторинг примера, чтобы использовать подход обновления функционального состояния:

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class CounterContainer extends React.Component {
  constructor(props) {
    ...
  }

# leanpub-start-insert
  onIncrement() {
    this.setState(prevState => ({
      counter: prevState.counter + 1
    }));
  }

  onDecrement() {
    this.setState(prevState => ({
      counter: prevState.counter - 1
    }));
  }
# leanpub-end-insert

  render() {
    ...
  }
}
~~~~~~~~

Функциональный подход открывает еще два преимущества. Во-первых, функция, которая используется в `this.setState()`, является чистой функцией. Там нет никаких побочных эффектов. Функция всегда будет возвращать один и тот же результат (следующее состояние), если даны одни и те же параметры (предыдущее состояние). Это делает его предсказуемым и использует преимущества функционального программирования. Во-вторых, поскольку функция является чистой, ее можно легко протестировать в модульном тесте и независимо от компонента. Это дает вам возможность протестировать обновления локального состояния как бизнес-логику, которая отделена от уровня представления. Вам нужно только извлечь функцию из компонента.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

# leanpub-start-insert
const incrementUpdate = prevState => ({
  counter: prevState.counter + 1
});

const decrementUpdate = prevState => ({
  counter: prevState.counter - 1
});
# leanpub-end-insert

class CounterContainer extends React.Component {
  constructor(props) {
    ...
  }

# leanpub-start-insert
  onIncrement() {
    this.setState(incrementUpdate);
  }

  onDecrement() {
    this.setState(decrementUpdate);
  }
# leanpub-end-insert

  render() {
    ...
  }
}
~~~~~~~~

Теперь вы можете протестировать чистые функции как бизнес-логику отдельно от уровня представления. В конце концов, вы можете задаться вопросом, когда использовать объект, а когда использовать функцию в `this.setState ()`? Рекомендуемые правила:

* Всегда используйте `this.setState()` с функцией, когда вы зависите от предыдущего состояния или реквизита.
* Используйте `this.setState()`только с объектом, если вы не зависите от предыдущих свойств.
* В случае неопределенности, по умолчанию используется `this.setState()`с функцией.

### Компоненты высшего порядка

Компоненты высшего порядка (HOC) могут применятся в нескольких вариантах использования. Одним из таких вариантов использования будет [элегантный способ условного рендеринга](https://www.robinwieruch.de/gentle-introduction-higher-order-components/). Но эта книга о управлении состоянием, так почему бы не использовать его для управления локальным состоянием компонента? Давайте вернемся к скорректированному примеру «Архив в списке».

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

class ArchiveableList extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      archivedItems: []
    };

    this.onArchive = this.onArchive.bind(this);
  }

  onArchive(id) {
    const { archivedItems } = this.state;

    this.setState({
      archivedItems: [...archivedItems, id]
    });
  }

  render() {
    const { list } = this.props;
    const { archivedItems } = this.state;

    const filteredList = list
      .filter(byArchived(archivedItems));

    return (
      <ul>
        {filteredList.map(item =>
          <li key={item.id}>
            <span>
              {item.name}
            </span>
            <span>
              <button
                type="button"
                onClick={() => this.onArchive(item.id)}
              >
                Archive
              </button>
            </span>
          </li>
        )}
      </ul>
    );
  }
}

function byArchived(archivedItems) {
  return function(item) {
    return !archivedItems.includes(item.id);
  };
}
~~~~~~~~

Компонент `ArchiveableList` имеет две цели. С одной стороны, это чистый компонент представления, который показывает элементы в списке. С другой стороны, это компонент контейнера с отслеживанием состояния, который отслеживает заархивированные элементы. Следовательно, вы можете разделить эти две обязанности на представление и логику, таким образом, на компонент представления и компонент контейнера. Это будет тот же рефакторинг, который вы делали ранее с компонентами `CounterContainer` и `CounterPresenter`. Однако другой подход может заключаться в том, чтобы перевести логику, в данном случае управление локальным состоянием, в компонент высшего порядка. Компоненты высшего порядка можно использовать повторно, и, таким образом, локальное управление состоянием может стать многоразовым для многих компонентов, а не только для одного.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

function byArchived(archivedItems) {
  return function(item) {
    return !archivedItems.includes(item.id);
  };
}

function withArchive(Component) {
  class WithArchive extends React.Component {
    constructor(props) {
      super(props);

      this.state = {
        archivedItems: []
      };

      this.onArchive = this.onArchive.bind(this);
    }

    onArchive(id) {
      const { archivedItems } = this.state;

      this.setState({
        archivedItems: [...archivedItems, id]
      });
    }

    render() {
      const { list } = this.props;
      const { archivedItems } = this.state;

      const filteredList = list
        .filter(byArchived(archivedItems));

      return <Component
        list={filteredList}
        onArchive={this.onArchive}
      />
    }
  }

  return WithArchive;
}
~~~~~~~~

В свою очередь, компонент `List` отображает только список и получает функцию в свой пропс для архивирования элемента.

{title="Code Playground",lang="javascript"}
~~~~~~~~
function List({ list, onArchive }) {
  return (
    <ul>
      {list.map(item =>
        <li key={item.id}>
          <span>
            {item.name}
          </span>
          <span>
            <button
              type="button"
              onClick={() => onArchive(item.id)}
            >
              Archive
            </button>
          </span>
        </li>
      )}
    </ul>
  );
}
~~~~~~~~

Теперь вы можете составить облегчающий работу со списком компонент с возможностью архивирования элементов в списке.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

function byArchived(archivedItems) { ... }

function withArchive(Component) { ... }

function List({ list, onArchive }) { ... }

const ListWithArchive = withArchive(List);

function App({ list }) {
  return <ListWithArchive list={list} />
}
~~~~~~~~

Компонент `List` будет отображать только элементы. Возможность архивирования элемента в компоненте `List` будет включена компонентом высшего порядка, который называется `withArchive`. Кроме того, HOC также может быть повторно использован в других компонентах `List` для управления состоянием заархивированных элементов. В конце концов, компоненты высшего порядка отлично подходят для извлечения управления локальных состояний из компонентов и повторного использования логики управления локальными состояниями в других компонентах.

### Постащики и потребители контекста в React

Контекстный API является мощной особенностью в React. Вы не часто будете видеть это при использовании простого React, но можете рассмотреть возможность его использования, когда ваше приложение React увеличивается в размере и глубине с точки зрения компонента. По сути, контекстный API React устраняет беспорядок передачи обязательных пропсов, необходимых каждому компоненту, по всему дереву компонентов. Чаще всего промежуточные компоненты не интересуются этими пропсами.

Но вы увидите это не только при использовании просто React. Чаще контекстный API React можно увидеть в действии при использовании внешней библиотеки управления состоянием, такой как Redux или MobX. Там вы часто получаете компонент `Provider` в верхней части иерархии компонентов, который связывает ваш уровень состояния (Redux / MobX / ...) с вашим уровнем представления (React). Компонент `Provider` получает состояние в качестве пропса, а после этого каждый дочерний компонент имеет неявный доступ к управляемому состоянию через Redux и MobX.

Вы помните последний раз, когда вам приходилось прокидвать пропсы нескольких компонентов вниз по дереву компонентов? В простом React, вы можете часто сталкиваются с этой проблемой, которая называется «бурением пропсами». Может случиться, что пара этих пропсов даже обязательна для каждого дочернего компонента. Таким образом, вам нужно будет передать пропсы каждому дочернему компоненту. В свою очередь это загромождает каждый промежуточный компонент, который должен передавать эти пропсы, не используя их самостоятельно.

Когда эти пропсы становятся обязательными, контекстный API React дает вам выход из этого беспорядка. Вместо того, чтобы явно передавать пропсы вниз каждому компоненту, вы можете скрыть пропсы, необходимые для каждого компонента, в контексте React и неявно передавать их вниз каждому компоненту. Контексты React невидимы по дереву компонентов. Если компоненту нужен доступ к контексту, он может получить его по требованию.

Каковы варианты использования для этого подхода? Например, ваше приложение может иметь настраиваемую цветную тему. Каждый компонент должен быть окрашен в зависимости от конфигурации. Конфигурация выбирается один раз с вашего сервера, но затем вы хотите сделать ее неявно доступной для всех компонентов. Поэтому вы можете использовать контекстный API React, чтобы предоставить каждому компоненту доступ к цветной теме. Вы должны будете предоставить цветную тему в верхней части иерархии компонентов и использовать ее в каждом компоненте, который находится где-то под ней.

Каковы варианты использования для этого подхода? Например, ваше приложение может иметь настраиваемую цветную тему. Каждый компонент должен быть окрашен в зависимости от конфигурации. Конфигурация выбирается один раз с вашего сервера, но затем вы хотите сделать ее неявно доступной для всех компонентов. Поэтому вы можете использовать контекстный API React, чтобы предоставить каждому компоненту доступ к цветной теме. Вы должны будете предоставить цветную тему в верхней части иерархии компонентов и использовать ее в каждом компоненте, который находится где-то под ней.

Во-первых, вы должны создать контекст, который дает вам доступ к компоненту Provider и Consumer. Когда вы создаете контекст с помощью React с помощью `createContext()`, вы можете передать ему начальное значение. Начальное значение может быть нулевым, поскольку у вас может не быть доступа к начальному значению в данный момент времени. В противном случае вы уже можете указать начальное значение.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import React from 'react';

const ThemeContext = React.createContext(null);

export default ThemeContext;
~~~~~~~~

Во-вторых, компонент А должен обеспечивать контекст. В данном случае это жестко закодированное значение `value`, но это может быть что угодно из состояния или пропса компонента. Значение контекста также может измениться при изменении локального состояния из-за вызова `setState()`. Компонент A отображает только компонент D, но делает контекст доступным для всех остальных его компонентов ниже. Одним из конечных компонентов будет компонент C, который в конечном итоге использует контекст.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import ThemeContext from './ThemeContext';

class A extends React.Component {
  render() {
    return (
      <ThemeContext.Provider value={'green'}>
        <D />
      </ThemeContext.Provider>
    );
  }
}
~~~~~~~~

В-третьих, в вашем компоненте C, где-то ниже компонента D, вы можете использовать объект контекста. Обратите внимание, что компоненту A не нужно ничего передавать через компонент D в пропсах, чтобы он достиг компонента C.

{title="Code Playground",lang="javascript"}
~~~~~~~~
import ThemeContext from './ThemeContext';

class C extends React.Component {
  render() {
    return (
      <ThemeContext.Consumer>
        {coloredTheme =>
          <div style={{ color: coloredTheme }}>
            Hello World
          </div>
        }
      </ThemeContext.Consumer>
    );
  }
}
~~~~~~~~

Компонент может получить свой стиль, используя контекст. Компонент Consumer делает передаваемый контекст доступным с помощью [рендер-пропсов](https://reactjs.org/docs/render-props.html). Как вы можете себе представить, следуя этому пути, каждый компонент, который должен быть стилизован в соответствии с цветной темой, может получить необходимую информацию из контекстного API React, используя компонент Consumer. Вам нужно только использовать компонент Provider, который передает значение один раз где-то над ними, а затем использует его вместе с компонентом Consumer. Вы можете прочитать больше о [контекстном API React в официальной документации](https://reactjs.org/docs/context.html).

Это основы для контекстного API React. У вас есть один компонент Provider, который делает свойства доступными в контексте React, и компоненты, которые используют контекст с помощью компонента Consumer. Как это относится к управлению состоянием? В основном этот подход, также называемый шаблоном поставщика, часто применяется, когда используется сложное решение для управления состоянием, которое делает объект(ы) состояния доступным на вашем уровне представления через контекст React. Таким образом, все состояние может быть доступно в каждом компоненте. Возможно, вы никогда не будете реализовывать шаблон поставщика самостоятельно, но, скорее всего, позже вы будете использовать его в сложном решении для управления состоянием, таком как Redux или MobX. Так что имейте это в виду. В противном случае контекст React может использоваться для хранения самого объекта состояния. Его можно использовать, когда состояние используется глобально в вашем приложении React, но вы пока не хотите вводить Redux или MobX.
