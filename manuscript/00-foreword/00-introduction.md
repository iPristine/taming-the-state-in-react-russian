# Вступление

Управление состоянием в веб-приложениях стало популярной темой в последние годы. [Одностраничные приложения (SPA)](https://en.wikipedia.org/wiki/Single-page_application) - которые загружаются только один раз с веб-сервера, но остаются интерактивными на клиенте - должны дать управление состоянием на клиенте. Они должны поддерживать согласованное состояние во фронтенд приложении , не отправляя запросов в бэкенд приложение. Они должны дать пользователю легкий и приятный опыт при использовании приложения. Это уже начинается при открытии всплывающего окна в вашем приложении. Должна быть возможность открыть и закрыть его. Так что кто-то должен знать об этом состоянии. Но кто управляет этим состоянием, если не бэкэнд приложения?

[[jQuery](https://en.wikipedia.org/wiki/JQuery) была популярной библиотекой до появления первых решений SPA, таких как Angular, Ember и Backbone. С самого начала управление состоянием не было большой проблемой в jQuery, потому что библиотека чаще всего использовалась только для выборочных манипуляций с DOM. Вы могли добавлять анимацию в ваш HTML, добавлять или удалять DOM-узлы или программно изменить стиль вашего HTML. Это делало веб-приложение более приятным, сделав их интерактивными.

Со временем код jQuery и, в целом, часть кода JavaScript в отличие от HTML и CSS выросли, и люди написали более сложные веб-приложения. В большинстве случаев это приводило к путанице в коде jQuery, где не только проблемы с управлением состоянием, но и отсутствовали общие рекомендации, такие как чистый код. Не было решения общей архитектуры для таких приложений, и люди изо всех сил пытались поддерживать его в больших приложениях.

Через некоторое время, появились решения для одностраничных приложений (SPA) такие как Angular, Ember и Backbone, чтобы дать нестрктурированным фронтенд приложениям подходящую архитектурную структуру. Большая часть одностраничных приложений основывается на шаблоне [Модель-Вид-Контроллер - model-view-controller (MVC)](https://en.wikipedia.org/wiki/Model-view-controller) чтобы разрабатывать приложение. Перечисленные фреймворки содержат все, что вам нужно, начиная от уровня вида чтобы показывать HTML в браузере до уровня модели для взаимодействия с вашем бэкендом, чтобы разрабатывать более сложные приложения. Термин SPA был придуман, потому что эти приложения единственный раз загружаются с веб сервер, как одна страница, но работают на стороне клиента. Они это капли HTML связанные JavaScriptом который содержит все что нужно приложению, чтобы работать на стороне клиента. При переходе к другой странице по другому URlу, нет дополнительных серверных запросов чтобы получит HTML и JavaScript. Одностраничное приложение взаимодействует с бэкендом только для того чтобы отправить или получить новые данные. Таким образом, изменяется только одна вещь - состояние внутри клиентского приложения, потому что данные считывается из и записываются в бэкенд и такие взаимодействия как попапы, фильтры и модальные окна должны работать. Но кто управляет этим состоянием, чтобы клиентская часть оставалачь согласованной?

Хотя все эти фреймворки закрепляли лучшие практики, шаблоны и архитектуры для первого поколения одностраничных приложений, управление состоянием стало повторяющейся проблемой для них. При взаимодействии с бэкендом для получения данных, было непонятно как управлять данными предсказумым путем. При срабатывании элементов связанных с видом, такими как модальные окна или попапы, во фронтенде часто не было установленно лучших практик управления их состояниями. Каждый фреймворк старался применить свое собственное решение для этого. Со временем, люди придумали свои лучшие практики и библиотеки, но это никогда не стало предсказуемым и последовательным опытом управления состоянием с четкими ограничениями.

У этих SPA-решений был один существенный недостаток, который привел, в первую очередь, к этой проблеме: в качестве фреймворков они пытались решить слишком много проблем одновременно. Поскольку они были первыми в своем роде, у них не было возможности решить все проблемы в мире SPA. В конце концов, они решили эти проблемы в другом поколении, когда на сцене появились другие SPA-решения.

Второе поколение SPA-решений, в том числе такие библиотеки, как React и Vue, ориентировано только на небольшие части приложения. Они сосредоточены на уровне Вида. Разработчику нужно выбрать дополнительные библиотеки для решения конкретных проблем. [Это то, что в первую очередь сделало React такой мощной библиотекой](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/), потому что каждый может решить расширить свои приложение с библиотеками, которые решают конкретные, но небольшие проблемы.

В настоящее время тонна статей и библиотек пытается решить проблему управления состоянием. Трудно найти постоянный источник правды, чтобы изучить управление состоянием в современных приложениях. Несмотря на то, что такие решения, как React, имеют собственную реализацию управления состоянием для локального состояния в компонентах, существует больше внешних решений, таких как библиотеки Redux и MobX, которые устанавливают сложное управление состоянием.

Тем не менее, ему не хватает единого руководства для навигации по всем этим различным решениям, чтобы прояснить различия и преимущества управления состоянием. Довольно часто, руководства пропускают пункт первоначального объяснения проблемы. Кроме того, вместо того, чтобы демонстрировать минимальный подход, они пытаются решить проблему управления состоянием, используя изощренные подходы. Но это может быть намного проще. Требуется только один ресурс для последовательного и конструктивного руководства процессом управления состоянием в современных приложениях. И это миссия этой книги.

Если вы хотите чему-то научиться, вы должны делать это шаг за шагом. Попытаться решить каждую атомную проблему после следующей. Не применять все сразу. Понять проблему и решить ее. Вот моя попытка с этой книгой: она учит не только Redux в React, но и управлению состоянием в современных приложениях. Это выходит за рамки документации библиотек управления состоянием, но применяет полученные знания в реальных приложениях из книги.

Книга следует центральной теме управлением состояния в современных приложениях. Он начинается с управления локальным состоянием в библиотеке представлений (React), указывает на его проблемы в более крупных приложениях и приведет к сложным решениям по управлению состоянием, таким как Redux и MobX. Пока вы читаете книгу, вы найдете примеры кода, которые иллюстрируют проблемы и решения. Я призываю вас поиграть с этими примерами, чтобы получить практический опыт. Вы даже можете попробовать применить эти фрагменты кода в вашем личном редакторе и поиграть с ними. Но не волнуйтесь, если это не сработает в начале. Я буду руководстводить вами, чтобы вы применили ваши знания в вашем редакторе во многих главах. Тем не менее, не стесняйтесь проверить свои знания на ранней стадии.

Это герои книги: локальное состояние (в React), Redux и MobX. Было бы невозможно написать книгу без новаторов, стоящих за этими решениями: [Дан Абрамов](https://twitter.com/dan_abramov), [Эндрю Кларк](https://twitter.com/acdlite) и [Мишель Вестстрат](https://twitter.com/mweststrate). Я полагаю, я могу поблагодарить их от имени сообщества за их усилия, направленные на то, чтобы сделать управление состоянием в современных приложениях последовательным и приятным опытом.
